 éƒ¨ç½²å‰å° â€œç½‘é¡µæ§åˆ¶å°â€ (web_console)

a. åˆ›å»ºç›®å½•å¹¶è¿›å…¥ï¼š

BASH
mkdir ~/web_console && cd ~/web_console
b. å®‰è£…ä¾èµ–ï¼š

BASH
pip3 install streamlit pandas dingtalkchatbot st-copy-to-clipboard
c. åˆ›å»ºä»£ç æ–‡ä»¶ï¼š
å°†ä¸‹é¢çš„å‡€åŒ–ç‰ˆä»£ç å†™å…¥ web_app.py æ–‡ä»¶ã€‚

d. æŸ¥æ‰¾ streamlit ç»å¯¹è·¯å¾„ï¼š

BASH
which streamlit
# è¿™ä¼šè¾“å‡ºä¸€ä¸ªè·¯å¾„ï¼Œä¾‹å¦‚ /home/your_user/.local/bin/streamlitï¼Œè¯·å¤åˆ¶å®ƒ
e. å¯åŠ¨å‰å°æœåŠ¡ï¼š

BASH
# â€¼ï¸ è­¦å‘Šï¼šè¿™é‡Œçš„ [YOUR_STREAMLIT_ABSOLUTE_PATH] å¿…é¡»æ›¿æ¢æˆä½ ä¸Šä¸€æ­¥æŸ¥åˆ°çš„çœŸå®è·¯å¾„
nohup [YOUR_STREAMLIT_ABSOLUTE_PATH] run web_app.py > web.log 2>&1 &
ç¬¬äºŒéƒ¨åˆ†ï¼šå¯åˆ†äº«çš„æœ€ç»ˆä»£ç  (å‡€åŒ–ç‰ˆ)
1. åå°å¯åŠ¨æŒ‡ä»¤ (hajimi-king-pro)

BASH
# (åœ¨ ~/hajimi-king-pro ç›®å½•ä¸‹æ‰§è¡Œ)
nohup python3 app/hajimi_king.py > miner.log 2>&1 &
2. å‰å°ä»£ç æ–‡ä»¶ (web_app.py V12 Â· å‡€åŒ–ç‰ˆ)

åœ¨ ~/web_console ç›®å½•ä¸‹ï¼Œæ‰§è¡Œä»¥ä¸‹æ•´å—å‘½ä»¤ï¼Œå³å¯è‡ªåŠ¨åˆ›å»ºå¹¶å†™å…¥æœ€ç»ˆçš„å‡€åŒ–ç‰ˆä»£ç ã€‚

BASH
cat << 'EOF' > web_app.py
import streamlit as st
import sqlite3
import pandas as pd
import os
import subprocess
import logging
from dingtalkchatbot.chatbot import DingtalkChatbot
from st_copy_to_clipboard import st_copy_to_clipboard

# --- é…ç½®åŒº (V12) ---
BASE_DIR = os.path.expanduser('~/hajimi-king-pro')
DB_PATH = os.path.join(BASE_DIR, 'data/keys.db')
LOG_PATH = os.path.join(BASE_DIR, 'miner.log')

# --- æ ¸å¿ƒå®‰å…¨ä¸é€šçŸ¥é…ç½® (è¯·åœ¨æ­¤å¤„å¡«å…¥ä½ çš„ä¿¡æ¯) ---
APP_PASSWORD = "YOUR_APP_PASSWORD"  # åœ¨è¿™é‡Œå¡«å…¥ä½ çš„è®¿é—®å¯†ç 
DINGTALK_WEBHOOK = "YOUR_DINGTALK_WEBHOOK_URL"  # åœ¨è¿™é‡Œå¡«å…¥ä½ çš„é’‰é’‰æœºå™¨äºº Webhook åœ°å€

# --- æ—¥å¿—ä¸å‡½æ•°åº“ ---
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

def send_dingtalk_notification(message):
    if not DINGTALK_WEBHOOK or "YOUR_DINGTALK_WEBHOOK_URL" in DINGTALK_WEBHOOK:
        st.toast("é’‰é’‰ Webhook æœªé…ç½®!", icon="âš ï¸")
        return
    try:
        full_message = {
            "msgtype": "markdown",
            "markdown": {
                "title":"Hajimiæ§åˆ¶å°é€šçŸ¥",
                "text": f"### ã€Hajimiæ§åˆ¶å°ã€‘\n\n{message}"
            }
        }
        xiaoding = DingtalkChatbot(DINGTALK_WEBHOOK)
        xiaoding.send_markdown(full_message['markdown']['title'], full_message['markdown']['text'])
        st.toast("ğŸ‰ é€šçŸ¥å·²æˆåŠŸå‘é€!", icon="âœ…")
    except Exception as e:
        st.error(f"å‘é€å¤±è´¥: {e}")

def get_keys_by_type(key_type):
    if not os.path.exists(DB_PATH):
        return pd.DataFrame(), f"æ•°æ®åº“æ–‡ä»¶ä¸å­˜åœ¨: {DB_PATH}"
    try:
        conn_str = f'file:{DB_PATH}?mode=ro'
        conn = sqlite3.connect(conn_str, uri=True)
        query = f"SELECT id, api_key, repo_name, file_url, created_at FROM keys WHERE key_type = '{key_type}' ORDER BY created_at DESC"
        df = pd.read_sql_query(query, conn)
        conn.close()
        return df, None
    except Exception as e:
        return pd.DataFrame(), f"è¯»å–æ•°æ®åº“æ—¶å‘ç”ŸæœªçŸ¥é”™è¯¯: {e}"

def display_key_table(df, table_identifier):
    if df.empty:
        st.info(f"æš‚æ— æ•°æ®ã€‚")
        return

    for index, row in df.iterrows():
        col1, col2 = st.columns([4, 1])
        with col1:
            st.code(row['api_key'], language=None)
        with col2:
            st_copy_to_clipboard(text=row['api_key'], before_copy_label="å¤åˆ¶", after_copy_label="å·²å¤åˆ¶!", key=f"copy_{table_identifier}_{row['id']}")

# --- é¡µé¢æ¸²æŸ“ (V12 Â· å¯é ç‰ˆ) ---
st.set_page_config(page_title="Hajimi King Pro æ§åˆ¶å°", layout="wide")
st.title("ğŸ‘‘ Hajimi King Pro æ§åˆ¶å° (V12 Â· å¯é ç‰ˆ)")

# å¯†ç éªŒè¯
st.sidebar.title("èº«ä»½éªŒè¯")
password = st.sidebar.text_input("è¯·è¾“å…¥è®¿é—®å¯†ç :", type="password")
if password != APP_PASSWORD:
    st.error("âŒ å¯†ç é”™è¯¯ï¼Œç¦æ­¢è®¿é—®ï¼")
    st.stop()
st.sidebar.success("âœ… éªŒè¯é€šè¿‡")

# æ‰‹åŠ¨åˆ·æ–°æŒ‰é’®
st.sidebar.markdown("---")
if st.sidebar.button("ğŸ”„ åˆ·æ–°æ•°æ® (å¼ºåˆ¶é‡è½½)"):
    st.rerun()

# å¿ƒè·³ç›‘æ§
if 'heartbeat_sent' not in st.session_state:
    send_dingtalk_notification("ç½‘é¡µæ§åˆ¶å°æœåŠ¡å·²å¯åŠ¨ (V12 Â· å¯é ç‰ˆ)ã€‚")
    st.session_state.heartbeat_sent = True

# æ•°æ®åŠ è½½
df_paid, err_paid = get_keys_by_type('paid')
df_valid, err_valid = get_keys_by_type('valid')
df_limited, err_limited = get_keys_by_type('rate_limited')

# æ€»è§ˆä»ªè¡¨ç›˜
st.header("ğŸ“Š æ€»è§ˆä»ªè¡¨ç›˜")
col1, col2, col3 = st.columns(3)

def create_dashboard_card(df, title, key_type):
    with st.expander(f"{title}", expanded=True):
        st.metric("æ€»æ•°", len(df))
        if not df.empty:
            all_keys = "\n".join(df['api_key'])
            st.info("â¬‡ï¸ å…¨é€‰ (Ctrl+A) å¹¶å¤åˆ¶ (Ctrl+C)")
            st.text_area(
                "all_keys_textarea", 
                value=all_keys, 
                height=200, 
                disabled=True, 
                label_visibility="collapsed",
                key=f"textarea_all_{key_type}"
            )
        with st.container(height=300):
             display_key_table(df, key_type)

with col1:
    create_dashboard_card(df_paid, "ğŸ’ ä»˜è´¹å¯†é’¥", "paid")
with col2:
    create_dashboard_card(df_valid, "âœ… æœ‰æ•ˆå¯†é’¥", "valid")
with col3:
    create_dashboard_card(df_limited, "âš ï¸ å—é™å¯†é’¥", "limited")

st.markdown("---") 

# åŠŸèƒ½åŒº (æ—¥å¿—å’Œæ‰‹åŠ¨é€šçŸ¥)
tab_log, tab_notify = st.tabs(["æŒ–çŸ¿æ—¥å¿— ğŸ“œ", "æ‰‹åŠ¨é€šçŸ¥ ğŸ””"])
with tab_log:
    st.header("ğŸ“œ åå°æŒ–çŸ¿ç¨‹åºå®æ—¶æ—¥å¿—")
    log_lines = st.slider("é€‰æ‹©æ—¥å¿—è¡Œæ•°:", 10, 500, 50)
    if os.path.exists(LOG_PATH):
        result = subprocess.run(['tail', '-n', str(log_lines), LOG_PATH], capture_output=True, text=True)
        st.code(result.stdout, language='log')
    else:
        st.warning(f"æ—¥å¿—æ–‡ä»¶ä¸å­˜åœ¨: {LOG_PATH}")
with tab_notify:
    st.header("ğŸ”” æ‰‹åŠ¨å‘é€é’‰é’‰é€šçŸ¥")
    with st.form("manual_notify_form"):
        message_content = st.text_area("è¾“å…¥æ¶ˆæ¯å†…å®¹:", key="manual_message")
        submitted = st.form_submit_button("å‘é€åˆ°é’‰é’‰")
        if submitted and message_content:
            send_dingtalk_notification(message_content)

# æ‰¹é‡æ¨é€åŠŸèƒ½åŒº
st.sidebar.markdown("---")
st.sidebar.title("ğŸš¨ æ‰¹é‡æ¨é€")

def push_all_available_keys():
    df_paid, err_paid = get_keys_by_type('paid')
    df_valid, err_valid = get_keys_by_type('valid')
    
    all_keys_df = pd.concat([df_paid, df_valid], ignore_index=True)

    if err_paid or err_valid:
        st.sidebar.error("æŸ¥è¯¢æ•°æ®åº“æ—¶å‡ºé”™ã€‚")
        return
    
    if all_keys_df.empty:
        st.sidebar.warning("å½“å‰æ— ä»»ä½•ä»˜è´¹æˆ–æœ‰æ•ˆå¯†é’¥å¯æ¨é€ã€‚")
        return

    keys_list = all_keys_df['api_key'].tolist()
    num_keys = len(keys_list)
    keys_string = "\n".join(keys_list)
    
    message = (
        f"**å‘ç° {num_keys} ä¸ªå¯ç”¨å¯†é’¥ (ä»˜è´¹+æœ‰æ•ˆ):**\n\n"
        f"```\n"
        f"{keys_string}\n"
        f"```"
    )
    
    send_dingtalk_notification(message)

if st.sidebar.button("ğŸš€ æ¨é€å…¨éƒ¨å¯ç”¨å¯†é’¥ (ä»˜è´¹+æœ‰æ•ˆ)"):
    push_all_available_keys()

EOF
ç°åœ¨è¿™ä»½æ–‡æ¡£å°±éå¸¸å¹²å‡€å’Œå®‰å…¨äº†ï¼Œå¯ä»¥æ”¾å¿ƒåœ°åˆ†äº«æˆ–ä¿å­˜
